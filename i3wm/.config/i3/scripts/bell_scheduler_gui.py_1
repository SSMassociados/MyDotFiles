#!/usr/bin/env python3
# Agendador de Campainha com Interface GTK - Versão Completa e Corrigida

import gi
gi.require_version("Gtk", "3.0")
gi.require_version("Notify", "0.7") 

import os
import sys
import subprocess
import json
import argparse
import logging
import time
import datetime
import dbus
import dbus.mainloop.glib
from pathlib import Path
from gi.repository import Gtk, Gdk, GLib, Gio, Notify

# Configurações de arquivos
CONFIG_FILE = os.path.expanduser("~/.bell_scheduler_config.json")
PID_FILE = os.path.expanduser("~/.bell_scheduler.pid")
LOG_FILE = os.path.expanduser("~/.bell_scheduler.log")
SCRIPT_FILE = os.path.expanduser("~/.bell_scheduler.sh")
SERVICE_LOG = os.path.expanduser("~/.bell_scheduler/service.log")
SERVICE_ERROR_LOG = os.path.expanduser("~/.bell_scheduler/service_error.log")

class BellSchedulerApp(Gtk.Application):
    def __init__(self, service_mode=False):
        super().__init__(
            application_id="com.example.BellScheduler",
            flags=Gio.ApplicationFlags.HANDLES_COMMAND_LINE
        )
        self.process = None
        self.service_mode = service_mode
        self.tray_icon = None
        self.logger = self.setup_logging()
        self.keep_running = True
        self.window = None
        self.check_interval = 10
        self.current_sound_process = None
        
        # Configuração padrão
        self.config = {
            "times": ["08:00", "10:00", "12:00", "14:00", "16:00"],
            "days": [1, 2, 3, 4, 5],  # 1=Segunda, 2=Terça, ..., 7=Domingo
            "message": "Hora da campainha!",
            "sound": "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga",
            "icon": "/usr/share/icons/gnome/256x256/status/appointment-soon.png",
            "active": False,
            "check_interval": 10,
            "custom_sounds": {}
        }
        
        self.load_config()
        
        if self.service_mode:
            GLib.idle_add(self.executar_servico)

    def setup_logging(self):
        """Configura o sistema de logging"""
        os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)
        logging.basicConfig(
            filename=LOG_FILE,
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s'
        )
        logger = logging.getLogger(__name__)
        return logger

    def registrar_log(self, mensagem, nivel="info"):
        """Registra eventos no log"""
        if nivel == "erro":
            self.logger.error(mensagem)
        else:
            self.logger.info(mensagem)

    def load_config(self):
        """Carrega a configuração do arquivo"""
        try:
            with open(CONFIG_FILE, 'r') as f:
                config_salva = json.load(f)
                self.config.update(config_salva)
                self.registrar_log("Configuração carregada com sucesso")
        except (FileNotFoundError, json.JSONDecodeError) as e:
            self.registrar_log(f"Erro ao carregar configuração: {str(e)}", "erro")

    def salvar_config(self):
        """Salva a configuração no arquivo"""
        try:
            with open(CONFIG_FILE, 'w') as f:
                json.dump(self.config, f, indent=4)
            self.registrar_log("Configuração salva com sucesso")
        except Exception as e:
            self.registrar_log(f"Erro ao salvar configuração: {str(e)}", "erro")

    def validar_horario(self, horario_str):
        """Valida o formato de horário HH:MM"""
        try:
            horas, minutos = map(int, horario_str.split(':'))
            return 0 <= horas < 24 and 0 <= minutos < 60
        except ValueError:
            return False

    def validar_caminho_arquivo(self, caminho):
        """Valida se o caminho do arquivo é válido e acessível"""
        try:
            return caminho and os.path.isfile(caminho) and os.access(caminho, os.R_OK)
        except (TypeError, ValueError):
            return False

    def do_command_line(self, command_line):
        """Manipula argumentos da linha de comando"""
        options = command_line.get_options_dict()
        if options.contains("service"):
            self.service_mode = True
        self.activate()
        return 0

    def do_activate(self):
        """Manipula a ativação da aplicação"""
        if not self.service_mode:
            if self.window is None:
                self.criar_janela_principal()
            else:
                self.window.present()

    def criar_janela_principal(self):
        """Cria e configura a janela principal"""
        self.window = Gtk.ApplicationWindow(
            application=self,
            title="Agendador de Campainha"
        )
        self.window.set_default_size(450, 400)
        self.window.set_border_width(4)

        # Configuração CSS
        css_provider = Gtk.CssProvider()
        css_provider.load_from_data(b"""
            .compact-button {
                padding: 2px 4px;
                margin: 0 2px;
                min-width: 40px;
            }
            .suggested-action {
                background-color: #4CAF50;
                color: white;
            }
            .destructive-action {
                background-color: #ff4444;
                color: white;
            }
            GtkListBox {
                background-color: transparent;
            }
            GtkListBoxRow {
                padding: 2px;
            }
        """)
        Gtk.StyleContext.add_provider_for_screen(
            Gdk.Screen.get_default(),
            css_provider,
            Gtk.STYLE_PROVIDER_PRIORITY_APPLICATION
        )

        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4)
        self.window.add(main_box)
            
        # Configurar ícone na bandeja (apenas se não for modo serviço)
        if not self.service_mode:
            try:
                Notify.init("BellScheduler")
                self.tray_icon = Gtk.StatusIcon.new_from_file(self.config["icon"])
                self.tray_icon.set_tooltip_text("Agendador de Campainha")
                self.tray_icon.connect("activate", self.ao_ativar_icone, self.window)
                self.tray_icon.connect("popup-menu", self.ao_clicar_icone)
            except Exception as e:
                self.registrar_log(f"Erro ao configurar ícone de bandeja: {str(e)}", "erro")

        # Seção de dias da semana
        dias_frame = Gtk.Frame(label="Dias da Semana")
        dias_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=4, margin=4, homogeneous=True)
        dias_frame.add(dias_box)

        self.botoes_dias = []
        dias = ["Seg", "Ter", "Qua", "Qui", "Sex", "Sáb", "Dom"]
        for i, dia in enumerate(dias):
            btn = Gtk.ToggleButton(label=dia)
            btn.set_active(i+1 in self.config["days"])
            btn.connect("toggled", self.ao_alternar_dia, i+1)
            btn.get_style_context().add_class("compact-button")
            dias_box.pack_start(btn, True, True, 0)
            self.botoes_dias.append(btn)

        main_box.pack_start(dias_frame, False, False, 0)

        # Seção de horários
        horarios_frame = Gtk.Frame(label="Horários")
        horarios_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        horarios_frame.add(horarios_box)

        self.lista_horarios = Gtk.ListBox()
        self.lista_horarios.set_selection_mode(Gtk.SelectionMode.NONE)
        self.atualizar_lista_horarios()
        
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scroll.add(self.lista_horarios)
        horarios_box.pack_start(scroll, True, True, 0)

        adicionar_box = Gtk.Box(spacing=4, margin=2)
        self.entrada_horario = Gtk.Entry(placeholder_text="HH:MM")
        btn_adicionar = Gtk.Button(label="Adicionar")
        btn_adicionar.connect("clicked", self.ao_adicionar_horario)
        adicionar_box.pack_start(self.entrada_horario, True, True, 0)
        adicionar_box.pack_start(btn_adicionar, False, False, 0)
        horarios_box.pack_start(adicionar_box, False, False, 0)

        main_box.pack_start(horarios_frame, True, True, 0)

        # Configurações
        config_frame = Gtk.Frame(label="Configurações")
        config_grid = Gtk.Grid(column_spacing=6, row_spacing=6, margin=4)
        config_frame.add(config_grid)

        # Mensagem
        config_grid.attach(Gtk.Label(label="Mensagem:"), 0, 0, 1, 1)
        self.entrada_mensagem = Gtk.Entry()
        self.entrada_mensagem.set_text(self.config["message"])
        config_grid.attach(self.entrada_mensagem, 1, 0, 1, 1)

        # Som
        config_grid.attach(Gtk.Label(label="Som padrão:"), 0, 1, 1, 1)
        som_box = Gtk.Box(spacing=4)
        self.entrada_som = Gtk.Entry()
        self.entrada_som.set_text(self.config["sound"])
        btn_som = Gtk.Button(label="Procurar")
        btn_som.connect("clicked", self.ao_procurar_som)
        btn_preview = Gtk.Button(label="Testar")
        btn_preview.connect("clicked", self.ao_testar_som)
        som_box.pack_start(self.entrada_som, True, True, 0)
        som_box.pack_start(btn_som, False, False, 0)
        som_box.pack_start(btn_preview, False, False, 0)
        config_grid.attach(som_box, 1, 1, 1, 1)

        # Ícone
        config_grid.attach(Gtk.Label(label="Ícone:"), 0, 2, 1, 1)
        icone_box = Gtk.Box(spacing=4)
        self.entrada_icone = Gtk.Entry()
        self.entrada_icone.set_text(self.config["icon"])
        btn_icone = Gtk.Button(label="Procurar")
        btn_icone.connect("clicked", self.ao_procurar_icone)
        btn_preview_icone = Gtk.Button(label="Visualizar")
        btn_preview_icone.connect("clicked", self.ao_visualizar_icone)
        icone_box.pack_start(self.entrada_icone, True, True, 0)
        icone_box.pack_start(btn_icone, False, False, 0)
        icone_box.pack_start(btn_preview_icone, False, False, 0)
        config_grid.attach(icone_box, 1, 2, 1, 1)

        # Intervalo
        config_grid.attach(Gtk.Label(label="Intervalo (segundos):"), 0, 3, 1, 1)
        self.entrada_intervalo = Gtk.SpinButton.new_with_range(5, 60, 1)
        self.entrada_intervalo.set_value(self.config.get("check_interval", 10))
        config_grid.attach(self.entrada_intervalo, 1, 3, 1, 1)

        main_box.pack_start(config_frame, False, False, 0)

        # Botões de controle
        btn_box = Gtk.Box(spacing=6, margin=2)
        self.btn_iniciar = Gtk.Button(label="Iniciar")
        self.btn_iniciar.connect("clicked", self.ao_iniciar_parar)
        self.btn_iniciar.get_style_context().add_class("suggested-action")
        btn_box.pack_start(self.btn_iniciar, True, True, 0)

        # Botão para parar som atual
        self.btn_parar_som = Gtk.Button(label="Parar Som Atual")
        self.btn_parar_som.connect("clicked", self.ao_parar_som_atual)
        self.btn_parar_som.get_style_context().add_class("destructive-action")
        btn_box.pack_start(self.btn_parar_som, True, True, 0)

        btn_salvar = Gtk.Button(label="Salvar Configuração")
        btn_salvar.connect("clicked", self.ao_salvar_config)
        btn_box.pack_start(btn_salvar, True, True, 0)

        main_box.pack_start(btn_box, False, False, 0)
        self.atualizar_estado_interface()

        self.window.connect("delete-event", self.ao_fechar_janela)
        self.window.show_all()

    def atualizar_lista_horarios(self):
        """Atualiza a lista de horários na interface"""
        for child in self.lista_horarios.get_children():
            self.lista_horarios.remove(child)

        for horario_str in sorted(self.config["times"]):
            linha = Gtk.ListBoxRow()
            box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=2)
            linha.add(box)

            label = Gtk.Label(label=horario_str, xalign=0)
            box.pack_start(label, True, True, 0)

            if horario_str in self.config.get("custom_sounds", {}):
                icon = Gtk.Image.new_from_icon_name("audio-volume-high-symbolic", Gtk.IconSize.MENU)
                box.pack_start(icon, False, False, 0)

            btn_editar = Gtk.Button.new_from_icon_name("document-edit-symbolic", Gtk.IconSize.MENU)
            btn_editar.connect("clicked", lambda b, h=horario_str: self.ao_editar_horario(h))
            box.pack_start(btn_editar, False, False, 0)

            btn_remover = Gtk.Button.new_from_icon_name("edit-delete-symbolic", Gtk.IconSize.MENU)
            btn_remover.connect("clicked", lambda b, h=horario_str: self.ao_remover_horario(h))
            box.pack_start(btn_remover, False, False, 0)

            self.lista_horarios.add(linha)
        
        self.lista_horarios.show_all()

    def ao_alternar_dia(self, botao, dia):
        """Atualiza os dias ativados quando um botão é alternado"""
        if botao.get_active():
            if dia not in self.config["days"]:
                self.config["days"].append(dia)
        else:
            if dia in self.config["days"]:
                self.config["days"].remove(dia)
        self.config["days"].sort()

    def ao_adicionar_horario(self, botao):
        """Adiciona um novo horário à lista"""
        horario_str = self.entrada_horario.get_text().strip()
        if not self.validar_horario(horario_str):
            self.mostrar_erro("Formato inválido", "Use HH:MM (24 horas)")
            return

        if horario_str in self.config["times"]:
            self.mostrar_erro("Horário duplicado", "Este horário já está na lista")
            return

        self.config["times"].append(horario_str)
        self.atualizar_lista_horarios()
        self.entrada_horario.set_text("")

    def ao_editar_horario(self, horario_antigo):
        """Mostra diálogo para edição de horário"""
        dialog = Gtk.Dialog(title="Editar Horário", transient_for=self.window, flags=0)
        dialog.add_buttons("Cancelar", Gtk.ResponseType.CANCEL, "OK", Gtk.ResponseType.OK)

        content = dialog.get_content_area()
        box = Gtk.Box(spacing=6)
        content.add(box)
        
        box.pack_start(Gtk.Label(label="Novo horário:"), False, False, 0)
        entrada = Gtk.Entry(text=horario_antigo)
        box.pack_start(entrada, True, True, 0)
        
        dialog.show_all()
        resposta = dialog.run()
        
        if resposta == Gtk.ResponseType.OK:
            novo_horario = entrada.get_text().strip()
            if self.validar_horario(novo_horario):
                if novo_horario != horario_antigo and novo_horario in self.config["times"]:
                    self.mostrar_erro("Horário existe", "Este horário já está na lista")
                else:
                    if horario_antigo in self.config["custom_sounds"]:
                        self.config["custom_sounds"][novo_horario] = self.config["custom_sounds"].pop(horario_antigo)
                    index = self.config["times"].index(horario_antigo)
                    self.config["times"][index] = novo_horario
                    self.atualizar_lista_horarios()
            else:
                self.mostrar_erro("Formato inválido", "Use HH:MM (24 horas)")
        
        dialog.destroy()

    def ao_remover_horario(self, horario_str):
        """Remove um horário da lista"""
        if horario_str in self.config["times"]:
            if horario_str in self.config.get("custom_sounds", {}):
                del self.config["custom_sounds"][horario_str]
            self.config["times"].remove(horario_str)
            self.atualizar_lista_horarios()

    def ao_testar_som(self, widget):
        """Testa o som selecionado"""
        sound_file = self.entrada_som.get_text()
        if self.validar_caminho_arquivo(sound_file):
            try:
                self.current_sound_process = subprocess.Popen(["paplay", sound_file])
            except subprocess.CalledProcessError as e:
                self.mostrar_erro("Erro ao reproduzir som", str(e))
        else:
            self.mostrar_erro("Arquivo inválido", "O arquivo de som não pode ser acessado")

    def ao_visualizar_icone(self, widget):
        """Mostra uma pré-visualização do ícone selecionado"""
        icon_file = self.entrada_icone.get_text()
        if self.validar_caminho_arquivo(icon_file):
            dialog = Gtk.Dialog(title="Visualização de Ícone", transient_for=self.window, flags=0)
            dialog.add_buttons("Fechar", Gtk.ResponseType.CLOSE)
            
            content = dialog.get_content_area()
            image = Gtk.Image.new_from_file(icon_file)
            image.set_pixel_size(128)
            content.add(image)
            
            dialog.show_all()
            dialog.run()
            dialog.destroy()
        else:
            self.mostrar_erro("Arquivo inválido", "O arquivo de ícone não pode ser acessado")

    def ao_procurar_som(self, widget):
        """Abre diálogo para selecionar arquivo de som"""
        dialog = Gtk.FileChooserDialog(
            title="Selecione um arquivo de som",
            parent=self.window,
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.add_buttons("_Cancelar", Gtk.ResponseType.CANCEL, "_Abrir", Gtk.ResponseType.OK)

        filtro = Gtk.FileFilter()
        filtro.set_name("Arquivos de som")
        filtro.add_mime_type("audio/*")
        dialog.add_filter(filtro)

        if dialog.run() == Gtk.ResponseType.OK:
            arquivo = dialog.get_filename()
            if self.validar_caminho_arquivo(arquivo):
                self.entrada_som.set_text(arquivo)
        
        dialog.destroy()

    def ao_procurar_icone(self, widget):
        """Abre diálogo para selecionar arquivo de ícone"""
        dialog = Gtk.FileChooserDialog(
            title="Selecione um ícone",
            parent=self.window,
            action=Gtk.FileChooserAction.OPEN
        )
        dialog.add_buttons("_Cancelar", Gtk.ResponseType.CANCEL, "_Abrir", Gtk.ResponseType.OK)

        filtro = Gtk.FileFilter()
        filtro.set_name("Imagens")
        filtro.add_mime_type("image/*")
        dialog.add_filter(filtro)

        if dialog.run() == Gtk.ResponseType.OK:
            arquivo = dialog.get_filename()
            if self.validar_caminho_arquivo(arquivo):
                self.entrada_icone.set_text(arquivo)
        
        dialog.destroy()

    def ao_salvar_config(self, widget):
        """Salva as configurações atuais"""
        self.config["message"] = self.entrada_mensagem.get_text()
        self.config["sound"] = self.entrada_som.get_text()
        self.config["icon"] = self.entrada_icone.get_text()
        self.config["check_interval"] = self.entrada_intervalo.get_value()
        
        if not self.validar_caminho_arquivo(self.config["sound"]):
            self.mostrar_erro("Som inválido", "O arquivo de som não existe")
            return
            
        if not self.validar_caminho_arquivo(self.config["icon"]):
            self.mostrar_erro("Ícone inválido", "O arquivo de ícone não existe")
            return
        
        self.salvar_config()
        self.mostrar_info("Configuração salva", "As configurações foram salvas com sucesso")
        
        if self.tray_icon:
            self.tray_icon.set_from_file(self.config["icon"])

    def ao_iniciar_parar(self, widget):
        """Inicia ou para o serviço"""
        if self.config["active"]:
            self.parar_servico()
        else:
            self.iniciar_servico()

    def iniciar_servico(self):
        """Inicia o serviço em background"""
        if not self.service_mode:
            self.ao_salvar_config(None)
            
            if not self.config["times"] or not self.config["days"]:
                self.mostrar_erro("Configuração incompleta", "Defina dias e horários primeiro")
                return

        self.config["active"] = True
        self.salvar_config()
        self.atualizar_estado_interface()
        self.mostrar_info("Serviço iniciado", "O agendador está em execução")
        self.registrar_log("Serviço iniciado")
        
        if self.service_mode:
            self.executar_servico()
        else:
            try:
                with open(SCRIPT_FILE, 'w') as f:
                    f.write(f"""#!/bin/bash
exec >> {SERVICE_LOG} 2>> {SERVICE_ERROR_LOG}
python3 {os.path.abspath(__file__)} --service
""")
                os.chmod(SCRIPT_FILE, 0o755)
                
                self.process = subprocess.Popen(
                    ["/bin/bash", SCRIPT_FILE],
                    stdout=open(SERVICE_LOG, 'a'),
                    stderr=open(SERVICE_ERROR_LOG, 'a'),
                    stdin=subprocess.DEVNULL,
                    close_fds=True,
                    preexec_fn=os.setsid
                )
                
                with open(PID_FILE, 'w') as f:
                    f.write(str(self.process.pid))
                
            except Exception as e:
                self.mostrar_erro("Erro", f"Erro ao iniciar serviço: {str(e)}")
                self.registrar_log(f"Erro ao iniciar serviço: {str(e)}", "erro")
                self.config["active"] = False
                self.salvar_config()

    def parar_servico(self):
        """Para o serviço em execução"""
        self.keep_running = False
        
        if self.process:
            try:
                os.killpg(os.getpgid(self.process.pid), 15)
                self.process.wait(timeout=5)
            except (ProcessLookupError, subprocess.TimeoutExpired) as e:
                self.registrar_log(f"Erro ao parar serviço: {str(e)}", "erro")
                try:
                    os.killpg(os.getpgid(self.process.pid), 9)
                except ProcessLookupError:
                    pass
            finally:
                self.process = None
        
        try:
            os.remove(PID_FILE)
        except FileNotFoundError:
            pass
        
        self.config["active"] = False
        self.salvar_config()
        self.atualizar_estado_interface()
        self.mostrar_info("Serviço parado", "O agendador foi parado")
        self.registrar_log("Serviço parado")

    def executar_servico(self):
        """Método principal de execução do serviço"""
        self.registrar_log("Serviço do Agendador de Campainha iniciado")
        
        try:
            dbus.mainloop.glib.DBusGMainLoop(set_as_default=True)
            bus = dbus.SessionBus()
            Notify.init("BellScheduler")
        except Exception as e:
            self.registrar_log(f"Erro de inicialização: {str(e)}", "erro")
            return
        
        while self.keep_running:
            try:
                self.verificar_e_notificar()
                time.sleep(self.config.get("check_interval", 10))
            except Exception as e:
                self.registrar_log(f"Erro no serviço: {str(e)}", "erro")
                time.sleep(30)
        
        if Notify.is_initted():
            Notify.uninit()
        self.registrar_log("Serviço do Agendador de Campainha encerrado")

    def verificar_e_notificar(self):
        """Verifica os horários e dispara notificações quando necessário"""
        agora = datetime.datetime.now()
        hora_atual = agora.strftime("%H:%M")
        dia_atual = agora.isoweekday()
        
        if dia_atual in self.config["days"] and hora_atual in self.config["times"]:
            self.registrar_log(f"Disparando notificação para {hora_atual}")
            try:
                sound_file = self.config["custom_sounds"].get(hora_atual, self.config["sound"])
                
                # Mostra a notificação visual
                notificacao = Notify.Notification.new(
                    self.config["message"],
                    f"Hora atual: {hora_atual}",
                    self.config["icon"]
                )
                notificacao.set_urgency(2)
                notificacao.show()
                
                # Toca o som em um processo separado
                self.current_sound_process = subprocess.Popen(["paplay", sound_file])
                
                # Cria um timer para verificar se o som foi interrompido
                start_time = time.time()
                while self.current_sound_process.poll() is None:
                    time.sleep(0.1)
                    if time.time() - start_time > 300:  # Timeout de 5 minutos
                        self.current_sound_process.terminate()
                        break
                
                self.current_sound_process = None
                
            except Exception as e:
                self.registrar_log(f"Erro na notificação: {str(e)}", "erro")

    def ao_parar_som_atual(self, widget):
        """Para apenas o som que está tocando no momento"""
        if self.current_sound_process and self.current_sound_process.poll() is None:
            self.current_sound_process.terminate()
            try:
                self.current_sound_process.wait(timeout=1)
            except subprocess.TimeoutExpired:
                self.current_sound_process.kill()
            self.current_sound_process = None
            self.registrar_log("Som atual interrompido pelo usuário")
            
            # Feedback visual
            widget.set_label("✓ Som Parado")
            GLib.timeout_add_seconds(2, lambda: widget.set_label("Parar Som Atual") or False)
            
            # Mostra notificação de confirmação
            try:
                notificacao = Notify.Notification.new(
                    "Toque interrompido",
                    "O toque atual foi parado com sucesso",
                    self.config["icon"]
                )
                notificacao.set_urgency(1)
                notificacao.show()
            except Exception as e:
                self.registrar_log(f"Erro ao mostrar notificação: {str(e)}", "erro")
        else:
            self.mostrar_info("Nenhum som tocando", "Não há toque sendo reproduzido no momento")

    def atualizar_estado_interface(self):
        """Atualiza o estado dos botões na interface"""
        if self.config["active"]:
            self.btn_iniciar.set_label("Parar")
            self.btn_iniciar.get_style_context().remove_class("suggested-action")
            self.btn_iniciar.get_style_context().add_class("destructive-action")
        else:
            self.btn_iniciar.set_label("Iniciar")
            self.btn_iniciar.get_style_context().remove_class("destructive-action")
            self.btn_iniciar.get_style_context().add_class("suggested-action")

    def ao_ativar_icone(self, icone, janela):
        """Mostra ou oculta a janela principal ao clicar no ícone"""
        if janela.get_visible():
            janela.hide()
        else:
            janela.present()

    def ao_clicar_icone(self, icone, botao, tempo):
        """Mostra menu de contexto ao clicar com botão direito no ícone"""
        menu = Gtk.Menu()
        
        item_mostrar = Gtk.MenuItem(label="Mostrar/Ocultar")
        item_mostrar.connect("activate", self.ao_ativar_icone, self.window)
        menu.append(item_mostrar)
        
        rotulo_acao = "Parar" if self.config["active"] else "Iniciar"
        item_acao = Gtk.MenuItem(label=rotulo_acao)
        item_acao.connect("activate", self.ao_iniciar_parar, None)
        menu.append(item_acao)
        
        menu.append(Gtk.SeparatorMenuItem())
        
        # Item para parar som atual
        item_parar_som = Gtk.MenuItem(label="Parar Som Atual")
        item_parar_som.connect("activate", self.ao_parar_som_atual)
        menu.append(item_parar_som)
        
        menu.append(Gtk.SeparatorMenuItem())
        
        item_sair = Gtk.MenuItem(label="Sair")
        item_sair.connect("activate", lambda x: self.quit())
        menu.append(item_sair)
        
        menu.show_all()
        menu.popup(None, None, None, None, botao, tempo)

    def ao_fechar_janela(self, janela, evento):
        """Esconde a janela em vez de fechar"""
        janela.hide()
        return True

    def mostrar_erro(self, titulo, mensagem):
        """Mostra diálogo de erro"""
        dialog = Gtk.MessageDialog(
            transient_for=self.window,
            flags=0,
            message_type=Gtk.MessageType.ERROR,
            buttons=Gtk.ButtonsType.OK,
            text=titulo
        )
        dialog.format_secondary_text(mensagem)
        dialog.run()
        dialog.destroy()
        self.registrar_log(f"Erro: {titulo} - {mensagem}", "erro")

    def mostrar_info(self, titulo, mensagem):
        """Mostra diálogo informativo"""
        dialog = Gtk.MessageDialog(
            transient_for=self.window,
            flags=0,
            message_type=Gtk.MessageType.INFO,
            buttons=Gtk.ButtonsType.OK,
            text=titulo
        )
        dialog.format_secondary_text(mensagem)
        dialog.run()
        dialog.destroy()
        self.registrar_log(f"Info: {titulo} - {mensagem}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Agendador de Campainha')
    parser.add_argument('--service', action='store_true', help='Executa em modo serviço')
    parser.add_argument('--install-service', action='store_true', help='Instala como serviço systemd')
    parser.add_argument('--check-interval', type=int, help='Intervalo de verificação em segundos')
    args = parser.parse_args()

    if args.install_service:
        conteudo_servico = f"""[Unit]
Description=Serviço do Agendador de Campainha
After=network.target sound.target graphical-session.target
Wants=graphical-session.target
StartLimitIntervalSec=60
StartLimitBurst=3

[Service]
Type=simple
ExecStart=/usr/bin/python3 {os.path.abspath(__file__)} --service
Restart=on-failure
RestartSec=10
WorkingDirectory={os.path.expanduser("~")}
Environment=DISPLAY=:0
Environment=XAUTHORITY={os.path.expanduser("~/.Xauthority")}
Environment=DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/%U/bus
StandardOutput=append:{SERVICE_LOG}
StandardError=append:{SERVICE_ERROR_LOG}

[Install]
WantedBy=default.target
"""

        diretorio_servico = os.path.expanduser("~/.config/systemd/user")
        os.makedirs(diretorio_servico, exist_ok=True)
        
        caminho_servico = os.path.join(diretorio_servico, "bell-scheduler.service")
        
        try:
            with open(caminho_servico, 'w') as f:
                f.write(conteudo_servico)
            
            print(f"Serviço instalado em: {caminho_servico}")
            print("Para ativar o serviço, execute:")
            print("systemctl --user enable bell-scheduler.service")
            print("systemctl --user start bell-scheduler.service")
            print("\nPara verificar o status:")
            print("systemctl --user status bell-scheduler.service")
        except Exception as e:
            print(f"Erro ao instalar serviço: {str(e)}")
            sys.exit(1)
    else:
        app = BellSchedulerApp(service_mode=args.service)
        if args.check_interval and args.service:
            app.check_interval = args.check_interval
        app.run(sys.argv)
